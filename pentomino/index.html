<!doctype html>

<!-- <script src="main.js"></script> -->
<h1></h1>

<div id="root">
    <div>

<canvas id="tutorial" width="300" height="300"></canvas>

<!-- <input type="range" id="step" name="volume" min="0" max="10000" value="10"/> -->
<br>
<input type="number" id="iters" value="100"/>
<input type="button" id="run" value="ПУСК"/>
<input type="button" value="СБРОС" onclick="init()"/>
<input type="button" value="+1" onclick="repeatIterations(1)"/>

<div id="current-step" class="msg"></div>
<div id="found" class="msg"></div>
<div id="desc"></div>

<input type="button"  value="5×5" onclick="init55()"/>
<input type="button"  value="8×8 центр" onclick="init88center()"/>
<input type="button"  value="8×8 края" onclick="init88edges()"/>
<input type="button"  value="6×10" onclick="init610()"/>
<ul id="solutions"></ul>

    </div>
    <div>
<div onmouseover="drawStack()" onmouseout="draw()">Показать стэк</div>
<pre id="stack"></pre>
</div>

</div>
<style>
    #solutions {
        margin-top: 1rem;
    }
    #desc {
        margin-bottom: 1rem;
    }
    li {
        cursor: pointer;
    }
    .msg {
        font-size: 2rem;
    }
    #root {
        padding: 10px;
        display: flex;
    } 
    canvas {
        margin: auto auto;
      /* border: 1px solid black; */
    }
  </style>
<script>

const figures = [
    {color: "V", points: [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2]]},
    {color: "N", points: [[0, 0], [1, 0], [2, 0], [2, 1], [3, 1]]},
    {color: "N", points: [[0, 0], [-1, 1], [0, 1], [-1, 2], [-1, 3]]},
    {color: "I", points: [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0]]},
    {color: "W", points: [[0, 0], [1, 0], [1, 1], [2, 1], [2, 2]]},
    {color: "P", points: [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2]]},
    {color: "L", points: [[0, 0], [0, 1], [1, 1], [2, 1], [3, 1]]},
    {color: "L", points: [[0, 0], [-3, 1], [-2, 1], [-1, 1], [0, 1]]},
    {color: "L", points: [[0, 0], [0, 1], [0, 2], [0, 3], [1, 3]]},
    {color: "N", points: [[0, 0], [1, 0], [2, 0], [-1, 1], [0, 1]]},
    {color: "F", points: [[0, 0], [1, 0], [1, 1], [2, 1], [1, 2]]},
    {color: "U", points: [[0, 0], [1, 0], [1, 1], [0, 2], [1, 2]]},
    {color: "L", points: [[0, 0], [1, 0], [2, 0], [3, 0], [0, 1]]},
    {color: "U", points: [[0, 0], [1, 0], [0, 1], [0, 2], [1, 2]]},
    {color: "N", points: [[0, 0], [1, 0], [-2, 1], [-1, 1], [0, 1]]},
    {color: "L", points: [[0, 0], [1, 0], [0, 1], [0, 2], [0, 3]]},
    {color: "P", points: [[0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]},
    {color: "F", points: [[0, 0], [-1, 1], [0, 1], [0, 2], [1, 2]]},
    {color: "L", points: [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1]]},
    {color: "N", points: [[0, 0], [1, 0], [1, 1], [2, 1], [3, 1]]},
    {color: "W", points: [[0, 0], [1, 0], [-1, 1], [0, 1], [-1, 2]]},
    {color: "Z", points: [[0, 0], [1, 0], [0, 1], [-1, 2], [0, 2]]},
    {color: "Y", points: [[0, 0], [1, 0], [2, 0], [3, 0], [2, 1]]},
    {color: "U", points: [[0, 0], [2, 0], [0, 1], [1, 1], [2, 1]]},
    {color: "U", points: [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1]]},
    {color: "Z", points: [[0, 0], [1, 0], [1, 1], [1, 2], [2, 2]]},
    {color: "N", points: [[0, 0], [0, 1], [1, 1], [1, 2], [1, 3]]},
    {color: "F", points: [[0, 0], [0, 1], [1, 1], [-1, 2], [0, 2]]},
    {color: "Y", points: [[0, 0], [-1, 1], [0, 1], [1, 1], [2, 1]]},
    {color: "N", points: [[0, 0], [0, 1], [0, 2], [1, 2], [1, 3]]},
    {color: "Y", points: [[0, 0], [1, 0], [2, 0], [3, 0], [1, 1]]},
    {color: "P", points: [[0, 0], [-1, 1], [0, 1], [-1, 2], [0, 2]]},
    {color: "Y", points: [[0, 0], [0, 1], [0, 2], [1, 2], [0, 3]]},
    {color: "L", points: [[0, 0], [0, 1], [0, 2], [-1, 3], [0, 3]]},
    {color: "N", points: [[0, 0], [0, 1], [-1, 2], [0, 2], [-1, 3]]},
    {color: "P", points: [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1]]},
    {color: "Y", points: [[0, 0], [0, 1], [-1, 2], [0, 2], [0, 3]]},
    {color: "Y", points: [[0, 0], [-1, 1], [0, 1], [0, 2], [0, 3]]},
    {color: "Y", points: [[0, 0], [0, 1], [1, 1], [0, 2], [0, 3]]},
    {color: "F", points: [[0, 0], [0, 1], [1, 1], [2, 1], [1, 2]]},
    {color: "F", points: [[0, 0], [-1, 1], [0, 1], [1, 1], [-1, 2]]},
    {color: "P", points: [[0, 0], [1, 0], [2, 0], [1, 1], [2, 1]]},
    {color: "V", points: [[0, 0], [0, 1], [0, 2], [1, 2], [2, 2]]},
    {color: "T", points: [[0, 0], [1, 0], [2, 0], [1, 1], [1, 2]]},
    {color: "L", points: [[0, 0], [1, 0], [1, 1], [1, 2], [1, 3]]},
    {color: "F", points: [[0, 0], [1, 0], [-1, 1], [0, 1], [0, 2]]},
    {color: "P", points: [[0, 0], [0, 1], [1, 1], [0, 2], [1, 2]]},
    {color: "T", points: [[0, 0], [0, 1], [1, 1], [2, 1], [0, 2]]},
    {color: "W", points: [[0, 0], [0, 1], [1, 1], [1, 2], [2, 2]]},
    {color: "T", points: [[0, 0], [-2, 1], [-1, 1], [0, 1], [0, 2]]},
    {color: "V", points: [[0, 0], [0, 1], [-2, 2], [-1, 2], [0, 2]]},
    {color: "W", points: [[0, 0], [-1, 1], [0, 1], [-2, 2], [-1, 2]]},
    {color: "P", points: [[0, 0], [1, 0], [0, 1], [1, 1], [1, 2]]},
    {color: "Z", points: [[0, 0], [-2, 1], [-1, 1], [0, 1], [-2, 2]]},
    {color: "F", points: [[0, 0], [-2, 1], [-1, 1], [0, 1], [-1, 2]]},
    {color: "X", points: [[0, 0], [-1, 1], [0, 1], [1, 1], [0, 2]]},
    {color: "Y", points: [[0, 0], [-2, 1], [-1, 1], [0, 1], [1, 1]]},
    {color: "I", points: [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4]]},
    {color: "T", points: [[0, 0], [0, 1], [-1, 2], [0, 2], [1, 2]]},
    {color: "F", points: [[0, 0], [-1, 1], [0, 1], [1, 1], [1, 2]]},
    {color: "P", points: [[0, 0], [1, 0], [0, 1], [1, 1], [2, 1]]},
    {color: "V", points: [[0, 0], [1, 0], [2, 0], [0, 1], [0, 2]]},
    {color: "Z", points: [[0, 0], [0, 1], [1, 1], [2, 1], [2, 2]]},
  ]


const canvas = document.getElementById("tutorial")
const ctx = canvas.getContext("2d")

let xsize = 5
let ysize = 5
const qsize = 31
let solutions = []
let field = init2dArray(xsize, ysize)
let stack = []
let found = 0
let iteration = 0;

function init() {
    console.log("init")

    canvas.setAttribute("width", qsize * (xsize + 7) - 1)
    canvas.setAttribute("height", qsize * (ysize + 7) - 1)
    field = init2dArray(xsize, ysize)
    stack = [{status: "new"}]
    iteration = 0;
    found = 0
    solutions = []

    draw();
}
function sendMsg(text) {
    completeSearch = Math.pow(63, Math.floor(xsize * ysize / 5))
    document.getElementById("desc").innerText = 
    `Полный перебор ${completeSearch} итераций`

    solutionsElem = document.getElementById("solutions");
    solutionsElem.innerHTML = ''
    for (let g = 0; g < solutions.length; g++) {
        const el = document.createElement('li')
        el.innerText = `Решение ${g}, итер.: ${solutions[g].iteration}`
        el.onmouseover = () => drawSolution(g)
        el.onmouseout = () => draw()
      solutionsElem.appendChild(el)
    }
}

function init610() {
    xsize = 10; ysize = 6;
    init()
}
function init55() {
    xsize = 5; ysize = 5;
    init()
}

function init88center() {
    xsize = 8; ysize = 8;
    init()
    set([4, 4], -1)
    set([4, 3], -1)
    set([3, 3], -1)
    set([3, 4], -1)
    draw()
}

function init88edges() {
    xsize = 8; ysize = 8;
    init()
    set([0, 0], -1)
    set([0, -1], -1)
    set([-1, 0], -1)
    set([-1, -1], -1)
    draw()
}

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

const colors = {
  "V": "#8d184b",
  "N": "#d39216",
  "W": "#6b60b0",
  "L": "#b423af",
  "Z": "#1F2A8A",
  "F": "#E55137",
  "T": "#316650",
  "X": "#0E294B",
  "P": "#DE4C8A",
  "I": "#F5D033",
  "U": "#84C3BE",
  "Y": "#AAC3BE",
"free": "green",
"error": "red"};

function drawLine(x, y) {

    const xx = x + 3;
    const yy = y + 3;

    ctx.beginPath();

    const w = 2;
    ctx.moveTo( 
        xx * qsize + w,
        yy * qsize + w);
    ctx.lineTo( 
        xx * qsize + w,
        yy * qsize + qsize - w);

    ctx.moveTo( 
        xx * qsize + w,
        yy * qsize + w);
    ctx.lineTo( 
        xx * qsize + qsize - w,
        yy * qsize + w);

    ctx.moveTo( 
        xx * qsize + qsize - w,
        yy * qsize + w);
    ctx.lineTo( 
        xx * qsize + qsize - w,
        yy * qsize + qsize - w);

    ctx.moveTo( 
        xx * qsize + w,
        yy * qsize + qsize - w);
    ctx.lineTo( 
        xx * qsize + qsize - w,
        yy * qsize + qsize - w);

    // ctx.moveTo( j * qsize + 3, i * qsize + 2);
    // ctx.lineTo( j * qsize + qsize - 2 , i * qsize + 2);

    // ctx.moveTo( j * qsize, i * qsize);
    // ctx.lineTo( j * qsize + qsize, i * qsize );

    ctx.lineWidth = w;
    ctx.strokeStyle = "black";
    ctx.stroke();
}

function drawRect(x, y, color) {
    ctx.fillStyle = color || "#ccc"
    ctx.fillRect(
        (x + 3) * qsize + 2,
        (y + 3) * qsize + 2, 
        qsize - 4, 
        qsize - 4)

    if (color != null) {
      drawLine(x, y)
    }
}

function drawStack() {
    stack.slice(1).map(({color, points, allPoints}) => {
        points?.map(([x, y]) => {
            drawRect(x, y, colors[color] || color || "rgb(100 0 0 100%)")
        })
        allPoints?.map(([x, y]) => {
            drawRect(x, y, "red")
        })
    })
}

function drawSolution(n) {
    solutions[n].stack.map(({color, points}) => {
        points.map(([x, y]) => {
            drawRect(x, y, colors[color] || color || "rgb(100 0 0 100%)")
        })
    })

}

function printStack() {
    const tag = document.getElementById('stack')

    const s = [...stack].slice(1).reverse().map(e => {
        return (
            {name: e.name,
             status: e.status,
             color: e.color,
             seq: e.seq,
            points: e.points.map(([x, y]) => `[${x}, ${y}]`),
            allPoints: e.allPoints?.map(([x, y]) => `[${x}, ${y}]` )
            
        }
            )
    })

    tag.innerText = JSON.stringify(s, null, 2)
}

function draw() {

    sendMsg()
    printStack()
    document.getElementById("current-step").innerText = `итерация: ${iteration}`;
    document.getElementById("found").innerText = `найдено решений: ${found}`;

    ctx.clearRect(0, 0, ctx.canvas.width + 1, ctx.canvas.height + 1);
    

    ctx.beginPath();
    const w = 1;

    ctx.moveTo( 
        3 * qsize ,
        3 * qsize );
    ctx.lineTo( 
        3 * qsize ,
        3 * qsize + xsize * qsize);
    ctx.lineTo( 
        3 * qsize + ysize * qsize,
        3 * qsize + xsize * qsize);
    ctx.lineTo( 
        3 * qsize + ysize * qsize,
        3 * qsize);
    ctx.lineTo( 
        3 * qsize,
        3 * qsize);

    ctx.lineWidth = w;
    ctx.strokeStyle = "gray";
    ctx.stroke();
    xsize 
    ysize 
    qsize 

    drawStack();

    // for (i = 0; i < ysize; i++) {
    //     for (j = 0; j < xsize; j++) {
    //         const v = field[i][j];
    //         let color = "black";
    //         if (v === 0) {
    //             color = null
    //         } else if (v === -1) {
    //            color = `rgb(0 0 0 / 100%)`;
    //         } else {
    //             color = colors[v] || v || "rgb(100 0 0 100%)";
    //         }

    //         drawRect(j, i, color)
    //     }
    // }
}
window.addEventListener("load", main);

function isPointFit([x, y]) {
    return (
      (x >= 0 && x < xsize) &&
      (y >= 0 && y < ysize) &&
      field[y][x] == 0
    )
}

function isLastFigure(seq) {
  return seq >= figures.length - 1
}

function pushFigure(seq) {
    if (isLastFigure(seq)) {
      return;
    }

    const color = figures[seq].color;
    const points = figures[seq].points;

    const [freeX, freeY] = findFreePoint();

    const convertedPoints = points
      .map(([x, y]) => [freeX + x, freeY + y]);

    const fittedPoints =
        convertedPoints.filter(isPointFit)

    const isFigureFit = fittedPoints.length == 5

    const finalColor = color; // getRandomColor()
    
    stack.push({
        seq, 
        color: isFigureFit ? finalColor: "error",
        points: isFigureFit ? fittedPoints : [],
        allPoints: isFigureFit ? null : convertedPoints,
        status: isFigureFit ? "new" : "failed"
    })

    if (isFigureFit) {
    fittedPoints.map(point => set(point, isFigureFit ? finalColor : "error" ))
}
}

function popFigure(figure) {

    figure.points.map(point => set(point, 0))

}

function incIter() {
    iteration++;
}


// speed up
// when all near points are filled
// when solution is found
// when there is separation
function doIteration() {
    console.log("do")
    if (stack.length === 0) {
        // console.log("TOTAL FINISH", iteration);
        document.getElementById("current-step").innerText = `финиш ${iteration}`;
        return; 
    }

    incIter();
    const top = stack.pop();
    if (findFreePoint() == null) {
        popFigure(top);
        return pushFigure(top.seq + 1)
    } else if (top.status === "new") {
        top.status = "old"
        stack.push(top);
        pushFigure(0)
    } else if(top.status === "failed") {
        popFigure(top);
        pushFigure(top.seq + 1)
    } else if (top.status === "old") {
        popFigure(top);
        pushFigure(top.seq + 1)
    }
    if (findFreePoint() == null) {
        found++
        solutions.push({
            stack: stack.slice(1),
            iteration: iteration
        })
    }
}

function applyFigure({points, color}) {
    const [freeX, freeY] = findFreePoint();
    const convertedPoints = points
      .map(([x, y]) => [freeX + x, freeY + y]);

    convertedPoints.map(point => set(point, color))
}

function findFreePoint() {
    for (i = 0; i < ysize; i++) {
        for (j = 0; j < xsize; j++) {
            if (field[i][j] === 0)
              return [j, i];
        }
    }
    return null;
}

function printField(field) {
    field
        .map(line => console.log(line.map(el => el === 0 ? " " : "×").join('')))
        .join('\n')
}

function mod(num, div) {
    const r = num % div;
    return r === 0 || num > 0 && div > 0 ? r : r + div
}

function set(point, v) {
  const x = mod(point[0], xsize);
  const y = mod(point[1], ysize);
  field[y][x] = v;
}

function initArray(size) {
    const arr = Array(size);
    arr.fill(0);
    return arr;
}

function init2dArray(x, y) {
    const arr = initArray(y);
    return arr.map(() => initArray(x));
}

function repeatIterations(n) {
    for (let i = 0; i < n; i++) {
        //console.log("in repeat", i + 1)
        doIteration();
    }
    draw();
}

document.getElementById("run").onclick = () => {
    const n = document.getElementById("iters").value
    repeatIterations(n)
}

function main() {
    init55();
    repeatIterations(100)
}

</script>